# FormTrap Go API - Form Submission Handler

This document outlines the architecture and implementation details for the Go Gin API that handles public form submissions.

## Architecture Overview

**SvelteKit App** (port 5173) - Management UI for authenticated users
**Go Gin API** (port 8080 / submission.formtrap.io) - Public form submission handler

Both services connect to the same PostgreSQL database.

---

## Required Go Packages

### Core Framework & Database
```bash
go get github.com/gin-gonic/gin                    # HTTP framework
go get github.com/jackc/pgx/v5                     # PostgreSQL driver
go get github.com/jackc/pgx/v5/pgxpool             # Connection pooling
go get github.com/sqlc-dev/sqlc/cmd/sqlc@latest    # Type-safe SQL code generation
```

### File Storage (R2/S3)
```bash
go get github.com/aws/aws-sdk-go-v2
go get github.com/aws/aws-sdk-go-v2/config
go get github.com/aws/aws-sdk-go-v2/service/s3
go get github.com/aws/aws-sdk-go-v2/credentials
```

### Security & Validation
```bash
go get github.com/dutchcoders/go-clamd             # ClamAV virus scanning
go get github.com/oschwald/geoip2-golang           # IP geolocation
go get github.com/ulule/limiter/v3                 # Rate limiting
go get github.com/go-playground/validator/v10      # Request validation
go get github.com/badoux/checkmail                 # Email validation
```

### File Handling
```bash
go get github.com/h2non/filetype                   # File type detection (MIME)
```

### Utilities
```bash
go get github.com/google/uuid                      # UUID generation
go get github.com/rs/zerolog                       # Structured logging
go get github.com/joho/godotenv                    # Environment variables
go get github.com/redis/go-redis/v9                # Redis client
```

---

## Project Structure

```
formtrap-api/          # New Go project
â”œâ”€â”€ main.go
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ .env
â”œâ”€â”€ sqlc.yaml          # SQLC configuration
â”œâ”€â”€ sql/
â”‚   â”œâ”€â”€ schema.sql     # Database schema (copy from Drizzle)
â”‚   â””â”€â”€ queries.sql    # SQL queries for SQLC
â”œâ”€â”€ db/
â”‚   â””â”€â”€ sqlc/          # Generated by SQLC (don't edit)
â”œâ”€â”€ handlers/
â”‚   â””â”€â”€ forms.go       # Form submission handler
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ cors.go
â”‚   â”œâ”€â”€ ratelimit.go
â”‚   â””â”€â”€ spam.go
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ storage.go     # R2/file upload
â”‚   â”œâ”€â”€ email.go       # Email notifications
â”‚   â””â”€â”€ webhook.go     # Webhook calls
â””â”€â”€ pkg/
    â”œâ”€â”€ database.go    # PostgreSQL connection pool
    â””â”€â”€ redis.go       # Redis client
```

---

## SQLC Configuration

**Why SQLC?**
- Generates type-safe Go code from SQL queries
- Eliminates boilerplate and marshaling code
- Prevents SQL injection by design
- Compile-time checking of SQL queries

**sqlc.yaml:**
```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "sql/queries.sql"
    schema: "sql/schema.sql"
    gen:
      go:
        package: "db"
        out: "db/sqlc"
        emit_json_tags: true
        emit_prepared_queries: true
        emit_interface: false
        emit_exact_table_names: false
```

Generate code: `sqlc generate`

---

## Core Endpoint

**POST `/forms/:formId`** - Handle form submissions

### Environment Variables

```bash
# Database
DATABASE_URL=postgres://postgres:@localhost:5432/sveltekit

# Redis
REDIS_URL=redis://localhost:6379

# R2 Storage
R2_ACCOUNT_ID=xxx
R2_ACCESS_KEY_ID=xxx
R2_SECRET_ACCESS_KEY=xxx
R2_BUCKET_NAME=formtrap
R2_PUBLIC_URL=https://cdn.formtrap.io

# Mailgun
MAILGUN_API_KEY=xxx
MAILGUN_DOMAIN=mail.formtrap.io
MAILGUN_FROM_EMAIL=noreply@formtrap.io
MAILGUN_FROM_NAME=FormTrap

# Server
PORT=8080
MAX_DB_CONNECTIONS=50
MIN_DB_CONNECTIONS=5
```

---

## Database Connection Pooling (CRITICAL)

**Connection Pool Configuration:**

```go
package pkg

import (
    "context"
    "fmt"
    "os"
    "time"

    "github.com/jackc/pgx/v5/pgxpool"
)

func NewDatabasePool() (*pgxpool.Pool, error) {
    config, err := pgxpool.ParseConfig(os.Getenv("DATABASE_URL"))
    if err != nil {
        return nil, fmt.Errorf("unable to parse DATABASE_URL: %w", err)
    }

    // Connection pool settings
    config.MaxConns = 50                        // Max connections (adjust based on load)
    config.MinConns = 5                         // Min connections (always ready)
    config.MaxConnLifetime = 1 * time.Hour      // Recycle connections
    config.MaxConnIdleTime = 30 * time.Minute   // Close idle connections
    config.HealthCheckPeriod = 1 * time.Minute  // Check connection health

    pool, err := pgxpool.NewWithConfig(context.Background(), config)
    if err != nil {
        return nil, fmt.Errorf("unable to create connection pool: %w", err)
    }

    return pool, nil
}
```

**Connection Pool Best Practices:**
- âœ… Use pgxpool (not database/sql)
- âœ… Set reasonable MaxConns (20-50 for typical load)
- âœ… Set MinConns to keep connections warm
- âœ… Enable health checks
- âœ… Monitor pool metrics (active/idle connections)

---

## Validation Checklist

### Pre-Submission Validation (in order)

#### 1. Rate Limiting (Redis)
- Max 10 submissions per IP per hour
- Max 3 submissions per IP per minute to same form

#### 2. Fetch Form Context (SINGLE QUERY)

**CRITICAL: Use one query with JOINs to get all context**

```sql
-- sql/queries.sql
-- name: GetFormSubmissionContext :one
SELECT
    -- Form data
    f.id as form_id,
    f.name as form_name,
    f.is_active as form_is_active,
    f.allow_file_uploads,
    f.max_file_count,
    f.max_file_size,
    f.allowed_file_types,
    f.spam_check_enabled,
    f.honeypot_field_name,
    f.webhook_url,
    f.send_email_notifications,
    f.notification_emails,
    f.response_type,
    f.redirect_url,
    f.success_message,

    -- Organization data
    o.id as organization_id,
    o.name as organization_name,
    o.is_paused as organization_is_paused,

    -- Resource usage
    ru.used_storage_mb,
    ru.submissions_this_month,
    ru.total_submissions,

    -- Subscription limits
    s.max_submissions_per_month,
    s.max_storage_mb,
    s.status as subscription_status

FROM form f
INNER JOIN organization o ON f.organization_id = o.id
LEFT JOIN space_resource_usage ru ON ru.organization_id = o.id
INNER JOIN subscription s ON s.user_id = (
    SELECT user_id FROM member WHERE organization_id = o.id LIMIT 1
)
WHERE f.id = $1;
```

This query runs in ~5-10ms and gets ALL context needed for validation.

#### 3. In-Memory Validations (Fast)

After fetching context, validate in memory:

- âœ… Form exists (check query returned a row)
- âœ… Form is active (`form_is_active = true`)
- âœ… Space is not paused (`organization_is_paused = false`)
- âœ… Subscription is active (`subscription_status = 'active'`)

#### 4. **Spam Detection (BEFORE counting submission)** ðŸš¨

**CRITICAL ORDER: Check spam FIRST, before incrementing quota**

```go
// Check honeypot field
if ctx.SpamCheckEnabled {
    honeypotValue := formData[ctx.HoneypotFieldName]
    if honeypotValue != "" {
        // It's spam - save with isSpam=true but DON'T count towards quota
        return saveSpamSubmission(ctx, formData, "honeypot_filled")
    }
}

// Check IP blocklist (Redis)
isSpamIP, err := redisClient.SIsMember(ctx, "spam_ips", ipAddress).Result()
if err == nil && isSpamIP {
    return saveSpamSubmission(ctx, formData, "spam_ip")
}
```

**Spam IP Blocklist (Updated via Cron Job):**
- Daily cron job fetches spam IPs from free sources:
  - https://www.stopforumspam.com/downloads
  - https://www.abuseipdb.com (API)
  - Project Honey Pot
- Store in Redis Set: `SADD spam_ips [ip1] [ip2] ...`
- Lookup is O(1): `SISMEMBER spam_ips [ip]` (~1-2ms)
- **Don't call APIs during submission** - too slow

**If spam detected:**
```sql
-- Save submission with isSpam=true
-- DON'T increment counters
INSERT INTO submission (..., is_spam, spam_reason)
VALUES (..., true, $spam_reason)
```

#### 5. Subscription Limits (Only for Non-Spam)

```go
// Check monthly submission limit
if ctx.SubmissionsThisMonth >= ctx.MaxSubmissionsPerMonth {
    return &ValidationError{
        Code: "SUBMISSION_LIMIT_REACHED",
        Message: "Monthly submission limit reached"
    }
}

// Check storage limit (if files uploaded)
if hasFiles {
    totalFileSize := calculateTotalFileSize(files)
    if ctx.UsedStorageMb + (totalFileSize/1048576) > ctx.MaxStorageMb {
        return &ValidationError{
            Code: "STORAGE_LIMIT_REACHED",
            Message: "Storage limit reached"
        }
    }
}
```

#### 6. File Validation (If Uploads Allowed)

```go
if !ctx.AllowFileUploads && len(files) > 0 {
    return &ValidationError{Code: "FILE_UPLOADS_NOT_ALLOWED"}
}

if len(files) > ctx.MaxFileCount {
    return &ValidationError{Code: "TOO_MANY_FILES"}
}

for _, file := range files {
    // Check file size
    if file.Size > ctx.MaxFileSize {
        return &ValidationError{Code: "FILE_TOO_LARGE"}
    }

    // Check file type (if restricted)
    if ctx.AllowedFileTypes != "" {
        mimeType := detectMimeType(file)
        if !isAllowedMimeType(mimeType, ctx.AllowedFileTypes) {
            return &ValidationError{Code: "FILE_TYPE_NOT_ALLOWED"}
        }
    }
}
```

---

## ðŸš¨ CRITICAL: Atomic Database Operations

**NEVER do this (race condition):**
```go
// âŒ WRONG - Race condition!
count := getSubmissionCount(orgID)  // Read
count++                              // Increment in Go
updateSubmissionCount(orgID, count)  // Write
// Two concurrent requests can both read "10", both write "11" = data loss
```

**ALWAYS do this (atomic):**
```sql
-- âœ… CORRECT - Atomic at database level
-- sql/queries.sql
-- name: IncrementSubmissionCounters :exec
UPDATE space_resource_usage
SET
    submissions_this_month = submissions_this_month + 1,
    total_submissions = total_submissions + 1,
    updated_at = NOW()
WHERE organization_id = $1;
```

**Atomic operations needed for:**
- âœ… Increment `submissions_this_month`
- âœ… Increment `total_submissions`
- âœ… Increment `used_storage_mb` (when files uploaded)
- âœ… Decrement counters (when submissions deleted)

**CHECK constraints prevent negative values:**
```sql
-- Already in schema.ts
CHECK (submissions_this_month >= 0)
CHECK (total_submissions >= 0)
CHECK (used_storage_mb >= 0)
```

---

## Submission Processing Flow

### 1. Create Submission Record

Use a **transaction** for multi-step operations:

```sql
-- name: CreateSubmission :one
INSERT INTO submission (
    id, form_id, email, name, status, is_read, is_closed,
    data, ip_address, user_agent, referer, is_spam, spam_reason,
    created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW(), NOW()
)
RETURNING *;

-- name: IncrementCounters :exec
UPDATE space_resource_usage
SET
    submissions_this_month = submissions_this_month + 1,
    total_submissions = total_submissions + 1
WHERE organization_id = $1;
```

**Transaction in Go:**
```go
tx, err := pool.Begin(ctx)
if err != nil {
    return err
}
defer tx.Rollback(ctx)

// Create submission
submission, err := queries.CreateSubmission(ctx, tx, params)
if err != nil {
    return err
}

// Increment counters (atomic)
err = queries.IncrementCounters(ctx, tx, organizationID)
if err != nil {
    return err
}

// Upload files (if any)
if len(files) > 0 {
    err = uploadFilesToR2(files, submission.ID)
    if err != nil {
        return err // Rollback submission
    }
}

// Commit transaction
err = tx.Commit(ctx)
```

### 2. File Upload (If Applicable)

**Upload to R2/S3:**
```go
func uploadFilesToR2(files []*multipart.FileHeader, submissionID string) error {
    for _, file := range files {
        // Generate unique filename
        fileID := uuid.New().String()
        key := fmt.Sprintf("submissions/%s/%s", submissionID, fileID)

        // Upload to R2
        _, err := s3Client.PutObject(context.Background(), &s3.PutObjectInput{
            Bucket: aws.String(bucketName),
            Key:    aws.String(key),
            Body:   fileReader,
        })
        if err != nil {
            return err
        }

        // Update submission.files JSON
        // Store: {id, name, path, size, mime_type, uploaded_at}
    }

    return nil
}
```

**Virus Scanning (Optional but Recommended):**
```go
// Use ClamAV to scan uploaded files
func scanFileForVirus(file io.Reader) (bool, error) {
    c := clamd.NewClamd("/var/run/clamav/clamd.sock")

    response, err := c.ScanStream(file, make(chan bool))
    if err != nil {
        return false, err
    }

    for s := range response {
        if s.Status == clamd.RES_FOUND {
            return true, nil // Virus found
        }
    }

    return false, nil // Clean
}
```

### 3. Async Notifications (Don't Block Response)

**After successful submission, trigger notifications asynchronously:**

```go
// Don't wait for these - use goroutines
go func() {
    if ctx.SendEmailNotifications && len(ctx.NotificationEmails) > 0 {
        sendEmailNotification(submission, ctx.NotificationEmails)
    }
}()

go func() {
    if ctx.WebhookURL != "" {
        sendWebhook(ctx.WebhookURL, submission)
    }
}()

// Return success immediately (don't wait for email/webhook)
```

---

## Response Handling

### Success Response (Non-Spam)

```go
// Response type: "json"
if ctx.ResponseType == "json" {
    return c.JSON(200, gin.H{
        "success": true,
        "message": ctx.SuccessMessage,
        "submission_id": submission.ID,
    })
}

// Response type: "redirect"
if ctx.ResponseType == "redirect" {
    return c.Redirect(302, ctx.RedirectURL)
}
```

### Spam Response (Fool Bots)

**Return success even for spam** to prevent bots from learning:

```go
// Still return 200 OK for spam
return c.JSON(200, gin.H{
    "success": true,
    "message": "Thank you for your submission",
})
```

### Error Responses

```go
// Rate limit exceeded
return c.JSON(429, gin.H{
    "error": "RATE_LIMIT_EXCEEDED",
    "message": "Too many submissions. Please try again later.",
})

// Form not found
return c.JSON(404, gin.H{
    "error": "FORM_NOT_FOUND",
    "message": "Form not found",
})

// Form inactive
return c.JSON(403, gin.H{
    "error": "FORM_INACTIVE",
    "message": "This form is no longer accepting submissions",
})

// Submission limit reached
return c.JSON(403, gin.H{
    "error": "SUBMISSION_LIMIT_REACHED",
    "message": "Monthly submission limit reached",
})
```

---

## Performance Optimizations

### Target Metrics
- **Form lookup + validation:** 5-15ms (single query + in-memory checks)
- **File upload:** 50-200ms (depends on file size)
- **Total processing time:** 20-100ms (without file uploads)
- **Database connections:** Pooled, reused

### Optimization Strategies

1. **Single Database Query** - Get all context in one JOIN query
2. **Redis for Rate Limiting** - O(1) lookups, 1-2ms
3. **Redis for IP Blocklist** - SISMEMBER is O(1), ~1ms
4. **In-Memory Validations** - After fetching data, validate in Go (<1ms)
5. **Async Notifications** - Don't wait for email/webhook
6. **Connection Pooling** - Reuse connections, avoid handshake overhead
7. **Prepared Statements** - SQLC generates these automatically

---

## Database Indexes (Already Added to Schema)

These indexes are **critical** for Go API performance:

```sql
-- Submissions: lookup by form + created_at (for listing)
CREATE INDEX idx_submissions_form_created ON submission(form_id, created_at);

-- Submissions: filter spam (partial index)
CREATE INDEX idx_submissions_spam ON submission(is_spam) WHERE is_spam = true;

-- Submissions: form + spam filter
CREATE INDEX idx_submissions_form_spam ON submission(form_id, is_spam);

-- Forms: lookup by organization
CREATE INDEX idx_forms_organization ON form(organization_id);

-- Forms: lookup active forms by organization
CREATE INDEX idx_forms_org_active ON form(organization_id, is_active);
```

**Why these indexes matter:**
- `idx_submissions_form_created` - Used when listing submissions (by date)
- `idx_submissions_spam` - Partial index for spam queries (saves space)
- `idx_forms_organization` - Used in JOIN query to get form context
- `idx_forms_org_active` - Used when checking if form is active

---

## Redis Data Structures

### Rate Limiting
```redis
# Key format: ratelimit:ip:{ip_address}
# Expires after 1 hour
INCR ratelimit:ip:192.168.1.1
EXPIRE ratelimit:ip:192.168.1.1 3600
```

### Spam IP Blocklist
```redis
# Updated daily via cron job
SADD spam_ips 192.0.2.1 192.0.2.2 ...
SISMEMBER spam_ips 192.0.2.1  # O(1) lookup
```

---

## Production Deployment

### Reverse Proxy Configuration (Nginx)

```nginx
# /etc/nginx/sites-available/formtrap

# SvelteKit (main app)
server {
    server_name formtrap.io;

    location / {
        proxy_pass http://localhost:5173;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

# Go API (form submissions)
server {
    server_name submission.formtrap.io;

    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;

        # CORS headers
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "POST, OPTIONS";
    }
}
```

### Systemd Service

```ini
# /etc/systemd/system/formtrap-api.service
[Unit]
Description=FormTrap Go API
After=network.target postgresql.service redis.service

[Service]
Type=simple
User=formtrap
WorkingDirectory=/opt/formtrap-api
ExecStart=/opt/formtrap-api/formtrap-api
Restart=always

[Install]
WantedBy=multi-user.target
```

### Environment Variables (Production)
```bash
DATABASE_URL=postgres://user:password@localhost:5432/formtrap
REDIS_URL=redis://localhost:6379
PORT=8080
GIN_MODE=release
```

---

## Monitoring & Observability

### Metrics to Track
- âœ… Request rate (requests/sec)
- âœ… Response time (p50, p95, p99)
- âœ… Database connection pool usage
- âœ… Redis hit rate
- âœ… File upload success rate
- âœ… Spam detection rate
- âœ… Email/webhook failure rate

### Logging (Zerolog)
```go
import "github.com/rs/zerolog/log"

log.Info().
    Str("form_id", formID).
    Str("submission_id", submissionID).
    Bool("is_spam", isSpam).
    Int64("processing_time_ms", elapsed).
    Msg("submission_processed")
```

---

## Cron Jobs

### Daily Spam IP Update
```bash
#!/bin/bash
# Update spam IP list from public sources

# Fetch from StopForumSpam
curl -s https://www.stopforumspam.com/downloads/listed_ip_1.zip | \
  gunzip | \
  redis-cli --pipe SADD spam_ips

# Set expiry (refresh daily)
redis-cli EXPIRE spam_ips 86400
```

### Monthly Submission Counter Reset
```bash
#!/bin/bash
# Reset monthly counters based on subscription billing cycle

psql $DATABASE_URL <<SQL
UPDATE space_resource_usage
SET submissions_this_month = 0
WHERE organization_id IN (
    SELECT DISTINCT o.id
    FROM organization o
    JOIN member m ON m.organization_id = o.id
    JOIN subscription s ON s.user_id = m.user_id
    WHERE s.current_period_end < NOW()
);
SQL
```

---

## Database Best Practices Summary

### âœ… Must-Do (Launch Critical)
1. Use atomic operations for all counters (UPDATE ... = ... + 1)
2. Use transactions for multi-step operations
3. Use SQLC for type-safe queries
4. Configure connection pooling (pgxpool)
5. Add proper indexes (already done in schema)
6. Add CHECK constraints (already done in schema)
7. Handle errors and distinguish error types

### âœ… Should-Do (Post-Launch)
8. Set up monitoring (request rate, response time, pool usage)
9. Implement automated backups (daily + WAL archiving)
10. Add slow query logging (queries >100ms)
11. Set up data retention cleanup job

### âœ… Can-Do Later (Optimization)
12. Query optimization based on production metrics
13. Implement caching layer (if needed)
14. Add read replicas (if read-heavy)
15. Archive old data (when dataset grows large)

---

## Development Workflow

### Local Development
```bash
# Start PostgreSQL + Redis
docker-compose up -d

# Generate SQLC code
sqlc generate

# Run Go API
go run main.go

# Hot reload (optional)
go install github.com/cosmtrek/air@latest
air
```

### Testing
```bash
# Unit tests
go test ./...

# Load testing
# Use hey or wrk to simulate concurrent submissions
hey -n 1000 -c 50 -m POST http://localhost:8080/forms/test-form-id
```

---

## Next Steps

1. Initialize Go module: `go mod init formtrap-api`
2. Install dependencies (packages listed above)
3. Set up SQLC configuration
4. Copy database schema from Drizzle to `sql/schema.sql`
5. Write SQL queries in `sql/queries.sql`
6. Generate SQLC code: `sqlc generate`
7. Implement form submission handler
8. Set up Redis connection
9. Implement rate limiting middleware
10. Implement spam detection
11. Set up R2/S3 client for file uploads
12. Test locally with sample submissions
13. Deploy to production
14. Set up monitoring and alerting

---

## Key Takeaways

**Architecture:**
- SvelteKit = Management UI (authenticated users)
- Go Gin = Public API (form submissions)
- Shared PostgreSQL database
- Redis for rate limiting and spam IP blocklist

**Performance:**
- Single query for all context (~5-10ms)
- Atomic database operations (no race conditions)
- Connection pooling (reuse connections)
- Async notifications (don't block)
- Target: 20-50ms per submission

**Security:**
- Spam detection BEFORE quota check
- CHECK constraints prevent negative counters
- Rate limiting per IP
- Virus scanning for uploads
- CORS for public API

**Database:**
- Use SQLC for type-safe queries
- Use pgxpool for connection pooling
- Atomic operations for counters
- Proper indexes for performance
- CHECK constraints for data integrity

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/sqlc-dev/pqtype"
)

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submission (
    id, form_id, email, name, status, is_read, is_closed,
    data, files, ip_address, user_agent, referer,
    device, device_type, os, browser, is_robot,
    is_spam, spam_reason, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, NOW(), NOW()
)
RETURNING id, form_id, email, name, status, is_read, is_closed, data, files, ip_address, user_agent, referer, device, device_type, os, browser, is_robot, is_spam, spam_score, spam_reason, webhook_sent, webhook_sent_at, email_sent, email_sent_at, created_at, updated_at, deleted_at
`

type CreateSubmissionParams struct {
	ID         string                `json:"id"`
	FormID     string                `json:"form_id"`
	Email      sql.NullString        `json:"email"`
	Name       sql.NullString        `json:"name"`
	Status     string                `json:"status"`
	IsRead     bool                  `json:"is_read"`
	IsClosed   bool                  `json:"is_closed"`
	Data       json.RawMessage       `json:"data"`
	Files      pqtype.NullRawMessage `json:"files"`
	IpAddress  sql.NullString        `json:"ip_address"`
	UserAgent  sql.NullString        `json:"user_agent"`
	Referer    sql.NullString        `json:"referer"`
	Device     sql.NullString        `json:"device"`
	DeviceType sql.NullString        `json:"device_type"`
	Os         sql.NullString        `json:"os"`
	Browser    sql.NullString        `json:"browser"`
	IsRobot    sql.NullBool          `json:"is_robot"`
	IsSpam     sql.NullBool          `json:"is_spam"`
	SpamReason sql.NullString        `json:"spam_reason"`
}

// Create a new form submission
func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.queryRow(ctx, q.createSubmissionStmt, createSubmission,
		arg.ID,
		arg.FormID,
		arg.Email,
		arg.Name,
		arg.Status,
		arg.IsRead,
		arg.IsClosed,
		arg.Data,
		arg.Files,
		arg.IpAddress,
		arg.UserAgent,
		arg.Referer,
		arg.Device,
		arg.DeviceType,
		arg.Os,
		arg.Browser,
		arg.IsRobot,
		arg.IsSpam,
		arg.SpamReason,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.FormID,
		&i.Email,
		&i.Name,
		&i.Status,
		&i.IsRead,
		&i.IsClosed,
		&i.Data,
		&i.Files,
		&i.IpAddress,
		&i.UserAgent,
		&i.Referer,
		&i.Device,
		&i.DeviceType,
		&i.Os,
		&i.Browser,
		&i.IsRobot,
		&i.IsSpam,
		&i.SpamScore,
		&i.SpamReason,
		&i.WebhookSent,
		&i.WebhookSentAt,
		&i.EmailSent,
		&i.EmailSentAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFormSubmissionContext = `-- name: GetFormSubmissionContext :one
SELECT
    -- Form data
    f.id as form_id,
    f.name as form_name,
    f.is_active as form_is_active,
    f.allow_file_uploads,
    f.max_file_count,
    f.max_file_size,
    f.allowed_file_types,
    f.spam_check_enabled,
    f.honeypot_field_name,
    f.webhook_url,
    f.send_email_notifications,
    f.notification_emails,
    f.response_type,
    f.redirect_url,
    f.success_message,

    -- Organization data
    o.id as organization_id,
    o.name as organization_name,
    o.is_paused as organization_is_paused,

    -- Resource usage
    COALESCE(ru.used_storage_mb, 0) as used_storage_mb,
    COALESCE(ru.submissions_this_month, 0) as submissions_this_month,
    COALESCE(ru.total_submissions, 0) as total_submissions,

    -- Subscription limits
    s.max_submissions_per_month,
    s.max_storage_mb,
    s.status as subscription_status

FROM form f
INNER JOIN organization o ON f.organization_id = o.id
LEFT JOIN space_resource_usage ru ON ru.organization_id = o.id
INNER JOIN member m ON m.organization_id = o.id
INNER JOIN subscription s ON s.user_id = m.user_id
WHERE f.id = $1
LIMIT 1
`

type GetFormSubmissionContextRow struct {
	FormID                 string         `json:"form_id"`
	FormName               string         `json:"form_name"`
	FormIsActive           bool           `json:"form_is_active"`
	AllowFileUploads       bool           `json:"allow_file_uploads"`
	MaxFileCount           sql.NullInt32  `json:"max_file_count"`
	MaxFileSize            sql.NullInt32  `json:"max_file_size"`
	AllowedFileTypes       sql.NullString `json:"allowed_file_types"`
	SpamCheckEnabled       bool           `json:"spam_check_enabled"`
	HoneypotFieldName      sql.NullString `json:"honeypot_field_name"`
	WebhookUrl             sql.NullString `json:"webhook_url"`
	SendEmailNotifications bool           `json:"send_email_notifications"`
	NotificationEmails     sql.NullString `json:"notification_emails"`
	ResponseType           string         `json:"response_type"`
	RedirectUrl            sql.NullString `json:"redirect_url"`
	SuccessMessage         sql.NullString `json:"success_message"`
	OrganizationID         string         `json:"organization_id"`
	OrganizationName       string         `json:"organization_name"`
	OrganizationIsPaused   bool           `json:"organization_is_paused"`
	UsedStorageMb          int32          `json:"used_storage_mb"`
	SubmissionsThisMonth   int32          `json:"submissions_this_month"`
	TotalSubmissions       int32          `json:"total_submissions"`
	MaxSubmissionsPerMonth int32          `json:"max_submissions_per_month"`
	MaxStorageMb           int32          `json:"max_storage_mb"`
	SubscriptionStatus     string         `json:"subscription_status"`
}

// Get all context needed for form submission validation in ONE query
func (q *Queries) GetFormSubmissionContext(ctx context.Context, id string) (GetFormSubmissionContextRow, error) {
	row := q.queryRow(ctx, q.getFormSubmissionContextStmt, getFormSubmissionContext, id)
	var i GetFormSubmissionContextRow
	err := row.Scan(
		&i.FormID,
		&i.FormName,
		&i.FormIsActive,
		&i.AllowFileUploads,
		&i.MaxFileCount,
		&i.MaxFileSize,
		&i.AllowedFileTypes,
		&i.SpamCheckEnabled,
		&i.HoneypotFieldName,
		&i.WebhookUrl,
		&i.SendEmailNotifications,
		&i.NotificationEmails,
		&i.ResponseType,
		&i.RedirectUrl,
		&i.SuccessMessage,
		&i.OrganizationID,
		&i.OrganizationName,
		&i.OrganizationIsPaused,
		&i.UsedStorageMb,
		&i.SubmissionsThisMonth,
		&i.TotalSubmissions,
		&i.MaxSubmissionsPerMonth,
		&i.MaxStorageMb,
		&i.SubscriptionStatus,
	)
	return i, err
}

const incrementStorageUsage = `-- name: IncrementStorageUsage :exec
UPDATE space_resource_usage
SET
    used_storage_mb = used_storage_mb + $2,
    updated_at = NOW()
WHERE organization_id = $1
`

type IncrementStorageUsageParams struct {
	OrganizationID string `json:"organization_id"`
	UsedStorageMb  int32  `json:"used_storage_mb"`
}

// Atomically increment storage usage
func (q *Queries) IncrementStorageUsage(ctx context.Context, arg IncrementStorageUsageParams) error {
	_, err := q.exec(ctx, q.incrementStorageUsageStmt, incrementStorageUsage, arg.OrganizationID, arg.UsedStorageMb)
	return err
}

const incrementSubmissionCounters = `-- name: IncrementSubmissionCounters :exec
UPDATE space_resource_usage
SET
    submissions_this_month = submissions_this_month + 1,
    total_submissions = total_submissions + 1,
    updated_at = NOW()
WHERE organization_id = $1
`

// Atomically increment submission counters (NON-SPAM submissions only)
func (q *Queries) IncrementSubmissionCounters(ctx context.Context, organizationID string) error {
	_, err := q.exec(ctx, q.incrementSubmissionCountersStmt, incrementSubmissionCounters, organizationID)
	return err
}

const markEmailSent = `-- name: MarkEmailSent :exec
UPDATE submission
SET
    email_sent = true,
    email_sent_at = NOW()
WHERE id = $1
`

// Mark email notification as sent
func (q *Queries) MarkEmailSent(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.markEmailSentStmt, markEmailSent, id)
	return err
}

const markWebhookSent = `-- name: MarkWebhookSent :exec
UPDATE submission
SET
    webhook_sent = true,
    webhook_sent_at = NOW()
WHERE id = $1
`

// Mark webhook as sent
func (q *Queries) MarkWebhookSent(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.markWebhookSentStmt, markWebhookSent, id)
	return err
}

const updateSubmissionFiles = `-- name: UpdateSubmissionFiles :exec
UPDATE submission
SET
    files = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSubmissionFilesParams struct {
	ID    string                `json:"id"`
	Files pqtype.NullRawMessage `json:"files"`
}

// Update submission with uploaded file metadata
func (q *Queries) UpdateSubmissionFiles(ctx context.Context, arg UpdateSubmissionFilesParams) error {
	_, err := q.exec(ctx, q.updateSubmissionFilesStmt, updateSubmissionFiles, arg.ID, arg.Files)
	return err
}
